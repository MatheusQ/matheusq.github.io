[{"categories":null,"content":"Contextualização Com certeza há diversas soluções para o problema de substituir um texto/expressão de dentro de um arquivo no Linux. A solução usada para este caso foi o uso dos comandos sed e find. Eu tinha vários arquivos texto (.txt) dentro de um diretório no Linux e todos esses arquivos tinham a expressão draft:true dentro deles. Eu precisava mudar essa mesma expressão em todos os arquivos para draft:false. Uma das soluções possíveis: usar o comando sed. Comando sed para substituir uma expressão em um único arquivo sed -i 's/draft: true/draft: false/g' ./dir/arq-1.txt Info A opção -i significa edição no local, ou seja, o sed vai editar/modificar o próprio arquivo passado como parâmetro. Sem esta opção, ao encontrar a expressão draft: true ele ia simplesmente imprimir draft: false na saída padrão do Linux (stdout), o Shell, e não ia alterar o arquivo ou substituir a expressão. Faça o teste. =D Outro ponto é a sintaxe de quando queremos usar o sed para substituir algo: sed -i 's/SubstituaIsso/PorIsso/g'. A letra s, no começo, significa que queremos substituir algo; a g no final significa que queremos fazer uma substituição global, ou seja, que todas as ocorrências encontradas sejam substituídas - e não somente a primeira ocorrência, que é o comportamento padrão a ser executado caso o g não seja colocado. find + sed para substituir uma expressão em mais de um arquivo O cenário é o seguinte: Como usar o sed para subtituir uma mesma expressão em todos os arquivos de uma vez? ","date":"10-12-2020","objectID":"/sed-para-substituir-conteudo-dentro-arquivo/:0:0","tags":["linux","sed","find"],"title":"Como usar o sed e o find para substituir texto dentro de um arquivo no linux","uri":"/sed-para-substituir-conteudo-dentro-arquivo/"},{"categories":null,"content":"find O comando find no linux procura por arquivos e diretórios. Por padrão faz uma busca recursiva! Entre as diversas e poderosas opções do find, existe a opção do próprio find executar comandos em seus resultados. Para visualizar melhor essa opção, veja o resultado do comando find ./ Veja que foram listados todos os arquivos e pastas dentro de ./. Com a opção -exec é possível executar um comando em cada um desses arquivos e pastas que o find listou. Já dá para ligar os pontos, certo? ","date":"10-12-2020","objectID":"/sed-para-substituir-conteudo-dentro-arquivo/:1:0","tags":["linux","sed","find"],"title":"Como usar o sed e o find para substituir texto dentro de um arquivo no linux","uri":"/sed-para-substituir-conteudo-dentro-arquivo/"},{"categories":null,"content":"find + sed O comando para aplicar o comando sed em todos os arquivos de um diretório usando find fica: find ./ -type f -exec sed -i 's/draft: true/draft: false/g' {} \\; Após aplicar o comando find, veja a repetição do comando cat nos arquivos: Info -type f diz para o find buscar somente arquivos, assim ele não lista diretórios como resultado; {} é onde o find substitui por seus resultados, completando o comando (exemplo: sed -i 's/draft: true/draft: false/g' **./dir/arq-1.txt** \\;); O fim do comando aplicado pelo find deve terminar em \\; quando queremos executar o comando informado -exec para cada resultado do find, um por vez. Quando queremos executar o comando passado em exec usando todos os resultados como parâmetro de uma vez só, ao invés do \\; usamos o +. ","date":"10-12-2020","objectID":"/sed-para-substituir-conteudo-dentro-arquivo/:2:0","tags":["linux","sed","find"],"title":"Como usar o sed e o find para substituir texto dentro de um arquivo no linux","uri":"/sed-para-substituir-conteudo-dentro-arquivo/"},{"categories":null,"content":"Resumo Em 2018, subi um blog em um servidor próprio usando wordpress. Depois, me mudei de cidade devido a um novo emprego e a gerência do servidor que ficava na casa dos meus pais se tornou mais difícil, além do tempo mais escasso. Pausei o projeto em 2019. Em Julho de 2020 resolvi retomar o blog. Analisei que wordpress exigiria encontrar algum serviço de hospedagem, envolveria custos e etc. Isso me incentivou buscar outras soluções e tecnologia, então me deparei com o github pages. Com o github pages você consegue hospedar gratuitamente um site do tipo estático, usar um domínio próprio e com certificado válido (by Let’s Encrypt) para HTTPS. Para me auxiliar a produzir um site estático legal eu encontrei o Hugo, que “é um dos mais populares geradores de site estáticos de código aberto (open-souce)”. Com o conjunto GitHub Pages e Hugo, retomei meu blog! Não resumido, historinha, porquês e etc Durante a faculdade, além do curso em si, duas coisas foram bem marcantes: 1. Ter trabalhado em uma iniciação científica, a qual o projeto de pesquisa foi de minha autoria 2. Ter feito estágio com pessoas fantásticas na área de infraestrutura, área tema da minha iniciação científica e também linha de carreira que eu queria seguir (e segui). Quando eu terminei a faculdade, a falta de contato com o estágio e o término do projeto de iniciação científica, além do desemprego, me motivaram a criar um blog. Produzir conteúdo e compartilhar conhecimento sobre a área que eu gosto são coisas que me inspiram e que me dão prazer. Então, na metade de 2018 inventei de subir um blog usando um rapsberry. Foi uma experiência fantástica. Houveram muitos aprendizados. Vale citar alguns vários: Descobri que as provedoras de internet bloqueiam tráfego entrante para clientes residencias nas portas “baixas”, como exemplo, 80 e 443; briguei com uma provedora de internet para fugir do CGNAT (ter um IPv4 público direto em meu modem, mesmo que dinâmico), a ter direito a tráfego entrante nas portas baixas, direito ao IPv6; configurei minha rede em pilha dupla, IPv4 e IPv6, e meu blog era acessível em ambos os protocolos aprendi a configurar o web server Apache; aprimorei meus conhecimentos no firewall iptables; aprendi a configurar o fail2ban para proteger minha conexão SSH; fiz um monitoramento básico do sistema com Logwatch; configurei o hostapd para o raspberry ser o roteador wi-fi da rede; configurei um DHCP server; fiz hardening do Apache e de outras configurações do Linux para aprimorar a segurança; desenvolvi scripts em Shell Script para automatizar atualizações, backups entre outras tarefas; aprendi a usar o cron; aprendi muito sobre boot, particionamento, lvm, MBR e GPT; até eletrônica: confira https://coisasdeinfra.com/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/ a instalar o wordpress e todo o necessário para botar o blog no ar etc Esse projeto com raspberry é o tipo de coisa que vou carregar comigo sempre, que vez ou outra eu vou contar, vou lembrar. Para mim esse projeto será uma lembrança tão importante quanto como deve ser para Bezos lembrar dos seus primórdios em uma garagem, rsrs. O ponto é: ali algo deu origem a um futuro próspero (independente da proporção). Não posso deixar de citar e agradecer meu amigo Bruno Costa, cara que conheci quando tinha uns 8 anos, e que em 2018 (15 anos depois) me emprestou, ingenuamente, sua placa raspberry, a qual tomei conta e não devolvi por 2 anos hahaha. Valeu, mano! Você fez parte disso. Então, depois de alguns meses de ter aprendido muita coisa e ter colocado o blog no ar, eu, que estava buscando emprego, consegui um e me mudei de cidade (e da casa dos meus pais). Fui trabalhar com infraestrutura. Objetivo de início de carreira cumprido. Com um mundo de novas coisas, novas rotinas, responsabilidades e um tempo mais escasso, a gerência do raspberry remotamente ficou mais difícil. Eu tinha um problema com a fonte de energia do raspberry, e vez ou outra, era necessário tirar da tomada e colocar de novo hah","date":"26-08-2020","objectID":"/sai-wordpress-entra-hugo/:0:0","tags":["blog","hugo","gohugo","open source","git","githubpages","linux","infraestrutura","segurança"],"title":"Relançamento do blog Coisas de Infra: sai Wordpress entra Hugo","uri":"/sai-wordpress-entra-hugo/"},{"categories":null,"content":"Vamos começar por “o que é Hugo?”. Ninguém melhor que o própria documentação do Hugo para explicar o que ele é, então lá vai a citação, com a minha tradução (perdoem erros) do site https://gohugo.io/about/what-is-hugo/ O que é Hugo Hugo é um gerador de sites estático rápido e moderno escrito em Go e projetado para tornar a criação de sites divertida novamente. Hugo é um framework de site de uso geral. Tecnicamente falando, Hugo é um gerador de sites estáticos. Ao contrário dos sistemas que constroem uma página dinamicamente com cada solicitação do visitante, Hugo constrói páginas quando você cria ou atualiza seu conteúdo. Uma vez que os sites são vistos com muito mais frequência do que editados, o Hugo foi projetado para fornecer uma experiência de visualização ideal para os usuários finais do seu site e uma experiência de escrita ideal para os autores do site. Os sites construídos com Hugo são extremamente rápidos e seguros. Os sites da Hugo podem ser hospedados em qualquer lugar, incluindo Netlify, Heroku, GoDaddy, DreamHost, GitHub Pages, GitLab Pages, Surge, Aerobatic, Firebase, Google Cloud Storage, Amazon S3, Rackspace, Azure e CloudFront e funcionam bem com CDNs. Os sites Hugo são executados sem a necessidade de um banco de dados ou dependências em tempos de execução caros, como Ruby, Python ou PHP. Para experimentar o Hugo, de maneira simples e rápida, eu segui o tutorial da página https://gohugo.io/getting-started/quick-start/. Depois, experimentei temas, coloquei mais conteúdos e fui moldando como queria colocar meus conteúdos no Hugo. ","date":"26-08-2020","objectID":"/sai-wordpress-entra-hugo/:1:0","tags":["blog","hugo","gohugo","open source","git","githubpages","linux","infraestrutura","segurança"],"title":"Relançamento do blog Coisas de Infra: sai Wordpress entra Hugo","uri":"/sai-wordpress-entra-hugo/"},{"categories":null,"content":"Seguindo com GitHub Pages Criei um repositório no GitHub para armazenar e versionar meus experimentos com Hugo. Então, estudei o GitHub Pages, pois precisava de um lugar/servidor para publicar meu site estático. E o GitHub Pages faz exatamente isso. Basta você criar um repositório com configurações específicas na sua conta que o Git vai interpretar o conteúdo colocado nesse repositório como um site estático. Ou seja, se for colocado arquivos HTML, CSS e companhia, devidamente estruturados, o Git vai interpretar e publicar como site para você. Depois, indo além nas configurações, é possível configurar um nome de domínio customizado (que seja seu, claro) e ativar HTTPS. ","date":"26-08-2020","objectID":"/sai-wordpress-entra-hugo/:2:0","tags":["blog","hugo","gohugo","open source","git","githubpages","linux","infraestrutura","segurança"],"title":"Relançamento do blog Coisas de Infra: sai Wordpress entra Hugo","uri":"/sai-wordpress-entra-hugo/"},{"categories":null,"content":"Veja como instalar o adaptador Wi-Fi USB Alfa AWUS03NH no Linux, um experimento de comparação entre o Wi-Fi interno de um Raspberry Pi 3 B e o Alfa, usando a ferramenta iperf3; e também como utilizá-lo em modo AP (Access Point / ponto de acesso Wi-Fi). Contextualização O que me levou a procurar um adaptador Wi-Fi USB (de boa qualidade) foi devido ao meu projeto de infraestrutura com Raspberry Pi 3 B. Nesse projeto eu configuro o Raspberry para ser o roteador/server da minha rede. Para saber mais sobre esse projeto, acesse aqui. Depois que concluí o projeto base, que era utilizar o Raspberry para fornecer rede Wi-Fi e gerir a rede toda (acesso a internet e rede local), surgiu uma pulga atrás da orelha: a força do sinal Wi-Fi na minha casa (onde o Rasp está hospedado). O que agravou o problema do sinal Wi-Fi emitido pelo Raspberry foi a utilização de um case, para que seja possível utilizar um cooler que por sua vez auxilia a dissipação de calor da placa. Esse case, de acrílico, deixa o Raspberry mais fechado/isolado e consequentemente se torna um obstáculo para a propagação do sinal Wi-Fi. Raspberry Pi 3 B em um case acrílico para acoplar cooler (ignora o dicionário como base de apoio, rsrs).Alt text \" Raspberry Pi 3 B em um case acrílico para acoplar cooler (ignora o dicionário como base de apoio, rsrs). Logo, achei que uma placa Wi-Fi externa, de preferência com antena externa também, me ajudaria a resolver o problema e propagar um sinal Wi-Fi de maior intensidade e qualidade pela casa. Depois de pesquisar, escolhi o adaptador Wi-Fi USB da marca ALFA, modelo AWUS036NH. Aparentemente ele é muito utilizado em conjunto com o Kali Linux – sistema Linux voltado para Pentest -, por Ethical Hackers, para que seja possível alcançar mais redes Wi-Fi do que uma placa de notebook consegue. Também é importante notar que os dispositivos originais utilizam chipsets Ralink, já que durante minhas pesquisas eu observei que há imitações desse dispositivo no mercado que utilizam outros chipsets e tem desempenho inferior. Então, fique atento! Caixa do produto (já vazia) e, a direita, adaptador alfa em um case que vem junto ao produto para fixação (há uma borracha de pressão embaixo do case) Eu utilizo meu notebook com monitor, teclado e mouse externos, e assim o deixo em uma “gaveta” embaixo da mesa, daquelas onde antigamente existiam para se apoiar o teclado do computador. Notebook fechado embaixo da mesaAlt text \" Notebook fechado embaixo da mesa Isso piorava mais ainda a situação do sinal Wi-Fi, e eu estava sofrendo (risos de nervoso). Depois de comprar o adaptador Alfa, decidi realizar um experimento para comparar a diferença que ele faria na qualidade do sinal Wi-Fi em relação ao do Raspberry. Acompanhe o experimento pelas próximas seções. Nota efetuei a compra do adaptador na loja Submarino. Foi naqueles esquemas de “vendido por loja X, entregue por loja Y”. Nesse caso, comprei via Submarino em uma loja chamada MicroPreços. Dispositivo original, show de bola! Instalação Nessa seção veremos o que é necessário fazer para usar o adaptador Wi-Fi alfa no Linux. Exemplifiquei a instalação em dois sistemas: Debian GNU/Linux 9.6 (stretch) e, no também baseado em Debian, Raspbian GNU/Linux 9.6 (stretch), o sistema Linux para Raspberry. ","date":"18-01-2019","objectID":"/instalacao-experimento-adaptador-alfa-linux/:0:0","tags":["wifi","iperf","linux","infraestrutura","raspberry","raspbian","iwlist","redes"],"title":"Instalação do Adaptador Wi-Fi USB Alfa AWUS036NH no Linux e Experimento de Desempenho","uri":"/instalacao-experimento-adaptador-alfa-linux/"},{"categories":null,"content":"Debian GNU/Linux 9.6 (stretch) No Debian, ao conectar o adaptador Wi-Fi USB no Raspberry e tentar “subí-lo” usando o comando ip link set dev wlan1 up, foi apresentado um erro ao carregar o módulo/driver que o sistema identificou ser o mais correto para o dispositivo: “firmware failed to load rt2870.bin”. Ao pesquisar, notei que o firmware proprietário da ralink foi removido do Linux desde a versão 2.6.30 do kernel. Por ser proprietário, não vem nativamente pré-instalado junto a distribuição Debian (eu não disse baseadas em Debian). O pacote deste firmware está disponível no repositório “non-free” do Debian. Então, bastou adicionar a linha deb http://ftp.us.debian.org/debian stretch main contrib non-free no arquivo /etc/apt/sources.list e prosseguir com a instalação dando o seguintes comandos: aptitude update aptitude install firmware-ralink Com o devido firmware/módulo instalado, basta dar o comando ip link set dev wlan1 up para que o adaptador fique disponível para uso sem nenhum problema. Depois de “subi-lo”, para que se possa usá-lo, é necessário configurá-lo manualmente. Para que isso não seja necessário, acredito que a melhor opção é configurar os parâmetros desejados para essa interface no arquivo /etc/network/interfaces e então utilizar as ferramentas ifup e ifdown para manipular a interface de rede. Dicas verifique a nomenclatura da sua interface e a especifique corretamente no comando ip link set dev interface up. No meu caso, o sistema reconheceu o adaptador como wlan1, mas o seu sistema pode reconhecer de maneira diferente. Dê o comando ip a ou ip link ou lshw -class network para identificar como a sua interface foi nomeada pelo sistema. Se quiser saber como configurar o arquivo interfaces do Linux e também entender melhor o sistema de nomenclatura de interfaces de rede do Linux, acesse o seguinte link: https://coisasdeinfra.com/raspberry-como-roteador-wi-fi-parte-3-do-projeto/ ","date":"18-01-2019","objectID":"/instalacao-experimento-adaptador-alfa-linux/:1:0","tags":["wifi","iperf","linux","infraestrutura","raspberry","raspbian","iwlist","redes"],"title":"Instalação do Adaptador Wi-Fi USB Alfa AWUS036NH no Linux e Experimento de Desempenho","uri":"/instalacao-experimento-adaptador-alfa-linux/"},{"categories":null,"content":"Raspberry – Raspbian GNU/Linux 9.6 (stretch) Já no Raspberry não foi necessária a instalação de nenhum driver ou firmware adicional. Veja como o sistema reconheceu o meu adaptador: Adaptador Alfa descrito no comando lshw -class networkAlt text \" Adaptador Alfa descrito no comando lshw -class network Além disso, não foi necessário alimentar (energizar) o adaptador de forma externa, como é feito com um HD Externo para que funcione no Raspberry, por exemplo. Bastou ligar diretamente na porta USB do Raspberry e usar. Porém, vale citar que no meu caso apenas o adaptador Wi-Fi está usando energia das portas USB. A única coisa a mais que tenho ligada é o HD Externo, mas esse é alimentado de forma externa. Saiba mais sobre isso em https://coisasdeinfra.com/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/. Experimento Para conseguir comparar de maneira mais científica, do que só olhar barrinha de sinal na barra de tarefas do S.O, se o adaptador Wi-Fi USB Alfa daria maior alcance e qualidade para o sinal Wi-Fi, elaborei o seguinte teste: Comando (no Linux) iwlist interfaceWiFi scanning para medir intensidade e qualidade do sinal Wi-Fi; Uso da ferramenta iperf3. Segundo o próprio site da ferramenta, https://iperf.fr/, ela serve para medir o máximo alcançável da largura de banda de redes IP, sendo compatível com vários protocolos (UDP, IPv6… por exemplo) e reportando vários tipos de dados de resultado; Fazer a medição e uso da ferramenta com meu notebook conectado ao Wi-Fi interno do Raspberry e depois repetir os mesmos testes com adaptador Alfa no mesmo lugar físico onde o Raspberry estava posicionado. Vamos aos testes! ","date":"18-01-2019","objectID":"/instalacao-experimento-adaptador-alfa-linux/:2:0","tags":["wifi","iperf","linux","infraestrutura","raspberry","raspbian","iwlist","redes"],"title":"Instalação do Adaptador Wi-Fi USB Alfa AWUS036NH no Linux e Experimento de Desempenho","uri":"/instalacao-experimento-adaptador-alfa-linux/"},{"categories":null,"content":"Medições e testes entre notebook e Wi-Fi interno do Raspberry Pi 3 B Emiti do meu notebook o comando iwlist wlp2s0 scanning (sendo wlp2s0 o nome da minha interface Wi-Fi) 3 vezes para elaborar uma média de dois dados que esse comando retorna, “Quality” e “Signal level”. Quanto a ferramenta iperf3, no lado servidor é necessário emitir o comando iperf3 -s e no lado cliente, para dar inicio ao teste, emitir o comando iperf3 -c ip do servidor -t 60. O -t 60 é para que a ferramenta fique 60 segundos fazendo o teste e depois te retorne uma média disso. Se nada for especificado, por padrão, o iperf3 faz um teste durante 10 segundos. Lembrete É necessário abrir a porta na qual o iperf funciona no lado servidor. A porta que o iperf3 trabalha é a 5201. Para liberá-la no iptables, segue a regra… iptables -A INPUT -p tcp –dport 5201 -i interface -j ACCEPT e/ou se for IPv6 ip6tables -A INPUT -p tcp –dport 5201 -i interface -j ACCEPT Como eu já citei na seção de Contextualização, eu uso meu notebook embaixo da mesa, apoiado naquela “gaveta” que antigamente se costumava utilizar para apoiar o teclado. Então resolvi testar duas condições: 1) teste com a gaveta fechada e 2) teste com a gaveta aberta Observação Estava esquecendo… tampa do notebook sempre fechada nos testes. ","date":"18-01-2019","objectID":"/instalacao-experimento-adaptador-alfa-linux/:3:0","tags":["wifi","iperf","linux","infraestrutura","raspberry","raspbian","iwlist","redes"],"title":"Instalação do Adaptador Wi-Fi USB Alfa AWUS036NH no Linux e Experimento de Desempenho","uri":"/instalacao-experimento-adaptador-alfa-linux/"},{"categories":null,"content":"Teste com a gaveta fechada Médias dos parâmetros de medição Quality e Signal level do comando iwlist wlp2s0 scanning: Quality 25/70 Signal level = -85dBm Resultado do teste com ferramenta iPerf3: Resultado do teste com a ferramenta iperf3: notebook (gaveta fechada) \u003c–\u003e RaspberryAlt text \" Resultado do teste com a ferramenta iperf3: notebook (gaveta fechada) Raspberry Como pode ser observado na imagem anterior, em um intervalo de 60 segundos foi transferido do notebook para o Raspberry 22MBytes de dados e a banda larga calculada foi de 3.11Mbits/sec. ","date":"18-01-2019","objectID":"/instalacao-experimento-adaptador-alfa-linux/:4:0","tags":["wifi","iperf","linux","infraestrutura","raspberry","raspbian","iwlist","redes"],"title":"Instalação do Adaptador Wi-Fi USB Alfa AWUS036NH no Linux e Experimento de Desempenho","uri":"/instalacao-experimento-adaptador-alfa-linux/"},{"categories":null,"content":"Teste com a gaveta aberta Só para entender melhor a situação de “gaveta aberta” segue imagem do significa isso: Médias dos parâmetros de medição Quality e Signal level do comando iwlist wlp2s0 scanning: Quality 21/70 Signal level = -89dBm Resultado do teste com ferramenta iPerf3: Resultado do teste com a ferramenta iperf3: notebook (gaveta aberta) \u003c–\u003e Raspberry Alt text \" Resultado do teste com a ferramenta iperf3: notebook (gaveta aberta) Raspberry Ao contrário da expectativa de que o sinal melhoraria com o notebook para fora da parte de baixo da mesa, as medições e os testes até pioraram um pouco. Os dados transferidos caíram de 22 para 14,8MBytes e a Banda de 3,11 para 2,08Mbits/sec. Medições e testes entre notebook e Adaptador Alfa Wi-Fi USB AWUS036NH Repetição dos mesmos testes realizados anteriormente. ","date":"18-01-2019","objectID":"/instalacao-experimento-adaptador-alfa-linux/:5:0","tags":["wifi","iperf","linux","infraestrutura","raspberry","raspbian","iwlist","redes"],"title":"Instalação do Adaptador Wi-Fi USB Alfa AWUS036NH no Linux e Experimento de Desempenho","uri":"/instalacao-experimento-adaptador-alfa-linux/"},{"categories":null,"content":"Teste com a gaveta fechada Médias dos parâmetros de medição Quality e Signal level do comando iwlist wlp2s0 scanning: Quality 45/70 Signal level = -65dBm Resultado do teste com ferramenta iPerf3: Resultado do teste com a ferramenta iperf3: notebook (gaveta fechada) \u003c–\u003e Adaptador AlfaAlt text \" Resultado do teste com a ferramenta iperf3: notebook (gaveta fechada) Adaptador Alfa Como foi possível notar na imagem anterior, a diferença dos resultados é espantosa. De 22MBytes transferidos e uma banda de 3Mbits/sec, pulamos para 138MBytes transferidos e 19,3Mbits/sec. Com o adaptador Alfa obtivemos 6 vezes mais velocidade e consequentemente dados transferidos, nesse primeiro teste. Teste com a gaveta aberta Médias dos parâmetros de medição Quality e Signal level do comando iwlist wlp2s0 scanning: Quality 48/70 Signal level = -62dBm Resultado do teste com ferramenta iPerf3: Resultado do teste com a ferramenta iperf3: notebook (gaveta aberta) \u003c–\u003e Adaptador AlfaAlt text \" Resultado do teste com a ferramenta iperf3: notebook (gaveta aberta) Adaptador Alfa Neste último teste tive a expectativa atendida, que foi a de que quando o notebook está mais exposto há uma melhora no sinal e consequentemente na banda de rede entre ele e o Raspberry com adaptador Alfa. Neste resultado melhoramos ainda um pouco mais: de 138MBytes transferidos e 19,3 Mbits/sec para 153MBytes de dados transferidos e banda de 21,4Mbits/sec. Esse resultado em relação ao mesmo teste quando o adaptador Wi-Fi era o interno do Raspberry, dá uma melhora de aproximadamente 10 vezes mais velocidade. Bônus: adaptador Wi-Fi USB Alfa AWUS036NH em modo AP Aqui, não é necessário nenhum trabalho, pois no blog já existe o “como fazer isso” pronto! Basta usar as mesmas configurações (iguaizinhas, até de driver) utilizadas no link a seguir: https://coisasdeinfra.com/raspberry-como-roteador-wi-fi-parte-3-do-projeto/#3_Instalacao_e_configuracao_do_servico_hostapd_para_fazer_do_Raspberry_um_ponto_de_acesso_Wi-Fi Conclusão Acredito que os resultados dos testes tenham indicado as seguintes conclusões: 1) envolver o Raspberry em um case + cooler diminui sua capacidade de alcance Wi-Fi. Além disso, o sinal aparenta oscilar mais (instabilidade). 2) Um adaptador Wi-Fi USB de qualidade, de preferência com antena externa, pode melhorar drasticamente a qualidade do sinal e consequentemente o fluxo da rede local. ","date":"18-01-2019","objectID":"/instalacao-experimento-adaptador-alfa-linux/:6:0","tags":["wifi","iperf","linux","infraestrutura","raspberry","raspbian","iwlist","redes"],"title":"Instalação do Adaptador Wi-Fi USB Alfa AWUS036NH no Linux e Experimento de Desempenho","uri":"/instalacao-experimento-adaptador-alfa-linux/"},{"categories":null,"content":"Contextualização Eis aqui uma parte opcional para o projeto, pois é possível manter o sistema rodando no cartão de memória como fizemos até agora. Porém, como eu já citei no artigo de Instalação (link), o cartão de memória tem um ciclo limitado de quantidade de leituras e escritas, podendo deixar de funcionar caso o limite for atingido. Procure pesquisar melhor este assunto. Esse link https://pt.stackoverflow.com/questions/8990/qual-é-a-vida-útil-de-um-cartão-sd-com-raspbian-raspberry-pi pode ser um bom começo. Outro ponto importantíssimo é a diferença de velocidade de leitura/escrita entre um cartão de memória e um HD Externo. Teremos uma seção neste artigo demonstrando essa grotesca diferença. Se esse for um ponto relevante para a sua decisão de migrar o Raspbian de um MicroSD para um HD Externo, dê uma espiada no resultado do teste de velocidade clicando aqui. Visto que o cartão de memória possui uma certa limitação na quantidade de escritas e menor velocidade de leitura/escrita de dados, torna-se atrativo executar o sistema Raspbian, no qual trabalhamos até agora, em um HD Externo. Porém, isso não é tão simples/trivial de se fazer. Acompanhe o artigo. Nesta parte teremos: Como fazer um HD Externo funcionar no Raspberry Esquemas de particionamento nativo (MBR), GPT e partições LVM; e quais diretórios Linux montar em partições separadas. Como copiar o sistema que já foi instalado e configurado no cartão de memória para o HD Externo Criar uma imagem initramfs Comparação de velocidade de leitura/escrita entre cartão de memória e HD Externo O que será necessário: Um HD Externo compatível com USB 2.0 (Opcional) Hub USB 2.0 de boa qualidade (Opcional) Materiais eletrônicos que serão descritos no artigo Para executar o sistema no HD Externo, requisito é criar initramfs 1. Como fazer um HD Externo funcionar no Raspberry “Então não é só plugar o HD Externo no Raspberry Pi 3 e sair usando?” Pois é, meu caro, não! Parece complicado, mas depois de ter apanhado um pouco disso, dá para simplificar. O sistema USB do Raspberry Pi 3 segue o padrão USB 2.0, e suas portas USB foram projetadas para serem utilizadas por dispositivos de baixa potência (Low-power device), que dentro do padrão 2.0 significa que esses dispositivos consomem até 100mA (miliampere). Ou seja, as portas USB do Raspberry Pi 3 fornecem até 100mA de energia para os dispositivos conectados. Exemplos de dispositivos de baixa potência são teclados e mouses. Já dispositivos de alta potência (High-power device), como um HD Externo, consome até o máximo estabelecido pelo padrão 2.0, que é 500mA, para que seja possível alimentar o rotor do disco e transferir dados a uma velocidade próxima do que o padrão 2.0 estabelece. Logo, ao olhar os números fica fácil entender porque o Raspberry Pi 3 não é capaz de “rodar” um HD Externo com excelência ou em sua máxima capacidade, pois o HD consome mais energia do que o Raspberry Pi 3 pode fornecer via porta USB. Simples! Então, para um HD Externo funcionar corretamente no Raspberry Pi 3, precisamos fornecer a energia de qual ele necessita (via USB) através de uma fonte externa. ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:0:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"Solução 1 Uma possível solução são os HUBs USB com fonte externa. Existem vários tipos, modelos e preços. Um exemplo é o da imagem a seguir: Hub USB 2.0 com fonte externa (baixa qualidade)Alt text \" Hub USB 2.0 com fonte externa (baixa qualidade) Mas nessa solução há um grande problema/risco. A maioria desse tipo de produto no mercado acaba causando um perigoso efeito chamado de “BackPowering” (ou “BackPower”). A ideia correta de usar um HUB alimentado é de que os dispositivos conectados a ele recebam energia da fonte de alimentação externa, assim eliminando a necessidade do Raspberry ter que alimentar esse dispositivo. O problema é que essa alimentação que vem da fonte externa também acaba indo para a conexão USB entre o HUB e o Raspberry, e então acontece o efeito do Raspberry receber energia via porta USB, como se tivesse recebendo alimentação de forma contrária ao circuito. Para explicar melhor, usando o HUB da imagem acima, ao ligá-lo no Raspberry Pi 3 desligado, as luzes de energia do Pi piscavam. Na verdade, aparentemente o Raspberry Pi 3 até poderia ser alimentado dessa maneira, mas nessa configuração ignoramos a proteção de voltagem do Raspberry, e qualquer tipo de oscilação poderia danificar nosso Rasp. Para resolver isso, basta “cortamos” o positivo da conexão entre o Raspberry e o HUB USB. No meu caso, com o HUB da imagem acima, nada disso deu certo, pois HUB era muito lento. ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:1:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"Conclusão da solução 1 Pesquise por HUBs USB que não tenham o efeito de “backpowering” (retorno de energia). Existem e são mais caros. Particularmente eu não achei nenhum facilmente, apenas encontrei relatos de pessoas em alguns fóruns que compraram. Se o achar e o preço couber no seu orçamento, compre! Se não tiver essa proteção contra backpower, considere cortar o positivo do cabo que vai do hub até o Raspberry ou ainda modifique o circuito impedindo o positivo do hub de chegar até a entrada USB do Rasp. Um Link que pode ajudar a encontrar HUBs USB que funcionem para o Pi é o https://elinux.org/RPi_Powered_USB_Hubs. ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:2:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"Solução 2 Aqui eu parti para a imaginação, e com as pouquíssimas habilidade adquiridas (e ainda lembradas) de um curso técnico em mecatrônica que fiz há 6 anos atrás, “projetei” uma adaptação técnica (vulgo gambiarra) que pode ser observada em duas imagens a seguir: Ilustração do esquema elétrico feito no software FritzingAlt text \" Ilustração do esquema elétrico feito no software Fritzing Esquema montado em um protoboardAlt text \" Esquema montado em um protoboard Eu comprei conectores USB fêmeas e cabos USB macho-macho. Protoboard e cabos conectores para o protoboard eu já tinha. 1 cabo macho-macho sai da fonte de alimentação externa (que também é a fonte do Raspberry, no meu caso) e se conecta em uma porta USB ligada ao protoboard. Essa porta USB terá como função “transferir” a sua energia para a outra porta ligada ao protoboard, onde está conectado o HD Externo. Como é possível observar na imagem Desenho do Esquema, somente os cabos vermelho e preto saem dessa primeira porta e se conectam com a porta do HD Externo, pois a função desses cabos é somente de fornecer alimentação (vermelho = positivo; preto = comum). Agora que o HD tem a energia necessária para funcionar adequadamente, basta interligar os conectores do HD e do Raspberry que transmitem dados entre si. Então, da porta que está o HD Externo, interligam-se os conectores D+, D- e GND com a porta em que está ligada ao Raspberry Pi 3 (via cabo USB macho-macho). Dessa forma, o positivo da fonte externa não está indo para o Raspberry, não causando o backpower. Somente os conectores de transmissão de dados e o comum/negativo (que tem que ser o mesmo para todos) estão saindo do HD Externo e indo para o Raspberry. Um problema enfrentado enquanto eu usava esse esquema no protoboard, foi o comprimento (total) dos cabos, e por esse motivo a comunicação entre HD Externo e Raspberry não funcionava. Todos os cabos tinham pouco mais de 1 metro. Quando consegui um cabo menor do HD Externo até a o protoboard, o problema já se resolveu. Eu consegui observar isso porque ao conectar o HD Externo direto no Rasp, ele funcionava normalmente, e quando conectava no protoboard (gambiarra), não funcionava. Claro que desconfiei da própria gambiarra e fiz vários testes. Mas no fim o problema era o comprimento dos cabos. Então, fica a dica para que use os menores cabos possíveis. Visto que a gambiarra no protoboard tinha funcionado, resolvi montar o esquema em uma placa de fenolite, onde eu poderia soldar os conectores USB e também soldar um cabo USB cortado diretamente na placa, resolvendo o problema de comprimento. O resultado pode ser visto na imagem a seguir. Placa com os componentes soldadosAlt text \" Placa com os componentes soldados ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:3:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"Conclusão da solução 2 Se você tiver uma noção mínima de eletrônica e tempo, acredito que vale a pena investir na criação da sua própria solução. Trará aprendizado e satisfação. Use a imaginação. Este link também explica sobre o backpower (retorno de energia, vamos dizer assim) fora do contexto com Raspberry e dá mais uma ideia de como evitar esse efeito. Vale à pena conferir. https://ryan.com.br/blogs/quicktalk/2012/12/usar-hubs-usb-com-alimentacao-externa-pode-ser-perigoso-para-seu-aparelho/ ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:4:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"Extra: Acredito que usar um HD Externo somente para fazer backup e/ou algumas transferências de arquivos pontuais não necessite de um esquema com alimentação externa. Executei testes onde foi escrito e lido 1GB de dados no HD Externo sem alimentação extra, e os dados foram copiados com sucesso. Mas para o sistema inteiro rodar no HD Externo sem alimentação externa, não funciona. Ocorrem erros no kernel e o sistema fica instável. ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:5:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"Extra 2: Se o seu HD Externo é USB 3.0 com compatibilidade para USB 2.0, recomendo que utilize um desses cabos utilizados para carregar smartphones Samsung, por exemplo, que são MicroUSB em uma ponta e USB comum na outra. Usando o cabo USB 3.0 que já vem com o HD, tive problemas de compatibilidade com a minha plaquinha usada para alimentar o HD. Ao utilizar o cabo MicroUSB, não tive problemas. A diferença ao utilizar o HD dessa maneira é que não teremos a velocidade USB 3.0 disponível, a qual já não era utilizada de qualquer maneira. HD externo USB 3.0 com cabo MicroUSB para funcionar em 2.0Alt text \" HD externo USB 3.0 com cabo MicroUSB para funcionar em 2.0 2. Esquemas de particionamento nativo (MBR), GPT e partições LVM; e quais diretórios Linux montar em partições separadas. Antes de tudo, é importante registrar que é possível iniciar o Raspbian a partir de uma unidade de armazenamento USB. Isso significa que poderíamos instalar o Raspbian em um Pen Drive ou HD Externo, conectá-lo ao Raspberry Pi 3 e iniciá-lo sem a necessidade de um cartão de memória. Porém, neste projeto não foi utilizada essa configuração, pois isso nos limita a utilizar o MBR como tabela de particionamento, além de que não conseguiríamos utilizar diferentes diretórios em outras partições. No projeto é utilizado somente o boot via cartão de memória (diretório boot e processo de boot), e o resto do sistema no HD Externo, permitindo que o HD tenha um esquema de particionamento GPT e também partições LVM, o que trás vantagens de gerenciamento e mais robustez. Nota Em meus experimentos, não fui capaz de iniciar o Raspbian em um HD com tabela de partições GPT ou com configuração híbrida MBR/GPT. Logo, concluo que ao utilizar o Raspberry Pi 3 para iniciar um sistema via USB, o HD Externo ou Pen Drive deverá manter o esquema original de quando se grava a imagem do sistema em disco, que é MBR. Quando gravamos a imagem do sistema Raspbian em um cartão de memória (ou HD, Pen Drive), nativamente a imagem utiliza a tabela de partição do tipo MBR. Este esquema nos limita a utilizar somente 4 partições primárias ou 3 primárias e 1 do tipo estendida, o que permite a criação de várias outras lógicas. Porém, partições lógicas são encadeadas e a perda de uma delas pode desencadear na perda das subsequentes, além de que há uma boa discussão sobre essas partições terem um desempenho menor no quesito velocidade. Outra restrição do MBR é em relação ao tamanho do disco, não particionando mais do que 2TB. Já a tabela de partição do tipo GPT (GUID Partition Table) pode ter até 128 partições primárias e trabalha com discos maiores que 2TB. Neste modelo as partições tem tamanho fixo e o redimensionamento é mais difícil. Com LVM (Logical Volume Manager) é possível alocar espaço do HD em volumes lógicos, como se fosse um particionamento virtual, o que torna o gerenciamento do tamanho das partições mais fácil, podendo adicionar ou retirar espaço e utilizar até mais de um HD para 1 partição, por exemplo. O legal deste modelo é que podemos definir tamanhos menores e mais racionais para as partições, e somente expandi-los conforme for necessário. O projeto seguirá com partições LVM, mas abordaremos partições GPT também. Em primeiro lugar, vou deixar definido o esquema de particionamento para o sistema Linux. Tenha esse esquema apenas como sugestão, considerando um HD de 1TB. Faça da maneira que achar melhor ou que for mais conveniente. Além disso, fique à vontade para discutir soluções de particionamento nos comentários. Lembrete Não se esqueça que a partição /boot já ficará separada no cartão de memória com o tamanho default da instalação. GPT Patição Nº Tamanho Ponto de montagem / Diretório 1 80GB / 2 200GB /home 3 150GB /usr 4 68GB /var 5 2GB /tmp Total 500GB LVM Patição Nº Tamanho Ponto de montagem / Diretório 1 20GB / 2 20GB /home 3 20GB /usr 4 20GB /var 5 1GB /tmp Total 81GB Com a repartição sugerida para GPT, provavelmente não será necessário uma “manutenção” para gerenciar espa","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:6:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"3.1. Criar nova tabela de partições GPT vazia Depois, ainda dentro do gdisk, digite a letra o para criar uma tabela de partição GPT vazia. Se houver alguma pergunta de confirmação, confirme com Y e prossiga. ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:7:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"3.2. Criar todas as partições conforme esquema que definimos anteriormente Agora vamos criar as partições que definimos anteriormente. Começaremos com a partição raíz, /. Digite n para criar uma nova partição. Em Partition number, dê enter para escolher o número default, 1. Em First sector também dê somente enter. Em Last sector vamos definir o tamanho que definimos, que é 80GB. Então digite: +80G e dê enter. Em Hex code, acredito que já estará definido o código 8300 se prosseguir somente com enter, código que indica que é uma partição do tipo Linux filesystem. Mas, para garantir, digite 8300 e dê enter. Pronto, a primeira partição está criada. Basta seguir criando as outras seguindo os mesmos passos e definindo os tamanhos que definimos para cada uma anteriormente. A imagem a seguir mostra como ficou esse processo para mim. Criação das partições na ferramenta gdiskAlt text \" Criação das partições na ferramenta gdisk Por fim, ainda dentro do gdisk, digite w (e faça as confirmações necessárias) para escrever todas as mudanças em disco e sair. Como pode ser observado na imagem a seguir, onde foi dado o comando fdisk -l, temos o HD com tabela de particionamento do tipo GPT e com as 5 partições que criamos com os tamanhos definidos. Resultado da criação das 5 partiçõesAlt text \" Resultado da criação das 5 partições ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:8:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"3.3. Formatar as partições com sistema de arquivos EXT4 Porém, as partições ainda não estão formatadas com o sistema de arquivos EXT4. Para formatar cada uma, seguem os comandos: mkfs.ext4 /dev/sda1 mkfs.ext4 /dev/sda2 mkfs.ext4 /dev/sda3 mkfs.ext4 /dev/sda4 mkfs.ext4 /dev/sda5 ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:9:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"3.4. Copiar o sistema Raspbian do cartão de memória para o HD (esquema GPT) Agora vamos copiar o sistema Raspbian do cartão de memória para o HD Externo e fazer as devidas configurações para que tudo funcione. Siga a sequência de passos a seguir. Primeiro, vamos criar um diretório para cada partição dentro de /mnt: mkdir /mnt/raiz mkdir /mnt/home mkdir /mnt/usr mkdir /mnt/var mkdir /mnt/tmp Agora, monte as devidas partições em seus respectivos diretórios: mount /dev/sda1 /mnt/raiz/ mount /dev/sda2 /mnt/home mount /dev/sda3 /mnt/usr mount /dev/sda4 /mnt/var mount /dev/sda5 /mnt/tmp Após esses comandos, ao dar um lsblk o resultado da montagem das partições do HD será como o da imagem a seguir: Montagem das partições nos diretórios criadosAlt text \" Montagem das partições nos diretórios criados Com todas as partições montadas em seus devidos diretórios, resta fazer a cópia do sistema. Para copiar do diretório / do cartão de memória todos os seus arquivos e subdiretórios para o HD, dê o comando: cp -ax / /mnt/raiz/ Info Onde, -a especifica que a estrutura original dos arquivos – atributos, permissões, links simbólicos, etc – devem ser preservadas, além de que faz a cópia recursiva, ou seja, copia diretórios. -x especifica que o cp deve operar somente no sistema de arquivos onde o comando foi executado. Se o cp tentar atravessar o limite para outro sistema de arquivos, esses arquivos serão ignorados. Isso inclui unidades de rede, outras partições, ou seja, qualquer arquivo que esteja em um ponto de montagem diferente. Só para exemplificar, nesse caso, o diretório /boot não será copiado para o HD, pois está montado em uma partição diferente de onde o comando cp foi executado. Mais precisamente, /boot está na partição /dev/mmcblk0p1 do cartão de memória e o comando cp está na partição raiz do sistema, /dev/mmcblk0p2. Se houver curiosidade, dê um ls no diretório /mnt/raiz/boot após a cópia terminar. Não haverá nada nele. Terminada a cópia do diretório raiz do cartão de memória para o HD Externo, devemos agora copiar os diretórios home, usr e var de /mnt/raiz para as partições que dedicamos exclusivamente para estes diretórios e que estão montadas em /mnt/home, /mnt/usr e /mnt/var respectivamente. Não é necessário copiar o diretório /mnt/raiz/tmp para /mnt/tmp, pois o conteúdo deste diretório é deletado a cada boot. Porém, foi importante montarmos este diretório mesmo assim, para nos lembrarmos posteriormente de apagar o conteúdo que está dentro do diretório raiz (/mnt/raiz/tmp). Para copiar os diretórios restantes para suas devidas partições dedicadas, dê: cp -ax /mnt/raiz/home/* /mnt/home/ cp -ax /mnt/raiz/usr/* /mnt/usr/ cp -ax /mnt/raiz/var/* /mnt/var/ Copiados todos os diretórios para suas devidas partições dedicadas, devemos apagar os conteúdos que estão nos diretórios home, usr, var e tmp dentro da partição /dev/sda1, que está montada em /mnt/raiz, porque quando iniciarmos o sistema a partir do HD perderemos acesso a eles, já que estes diretórios vão apontar para os conteúdos gravados em suas respectivas partições (sda2, sda3, sda4 e sda5). Para executar esta tarefa de deleção, dê: rm -rf /mnt/raiz/home/* rm -rf /mnt/raiz/usr/* rm -rf /mnt/raiz/var/* rm -rf /mnt/raiz/tmp/* ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:10:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"3.5. Realizar as devidas configurações para que tudo funcione Terminado o processo de cópia, falta apenas realizar algumas configurações para que o sistema no HD inicie corretamente. São dois passos, 1) parametrizar o arquivo de boot cmdline.txt para especificar que a partição raiz do sistema está no HD e não no cartão de memória; e 2) configurar os pontos de montagem das partições no arquivo fstab. Comece dando o comando o blkid. Este comando retorna atributos de um dispositivo/partição. Utilizaremos o identificador PARTUUID, que é o padrão utilizado nesses arquivos que vamos configurar pelo Raspbian. Anote-os. No meu caso, são os destacados em negrito a seguir: /dev/sda1: UUID=”02bd4d94-883d-4b85-826b-7327ec03b236″ TYPE=”ext4″ PARTLABEL=”Linux filesystem” PARTUUID=”f4a39e68-16b0-44c3-afd1-05dc0dea3973” /dev/sda2: UUID=”cdd69d1f-5a85-4d04-9a74-af15870b2625″ TYPE=”ext4″ PARTLABEL=”Linux filesystem” PARTUUID=”ab6f0c87-c856-40ab-8779-e7f0ab2414e8” /dev/sda3: UUID=”d48b7f36-9915-4966-b0d0-360ba665fd41″ TYPE=”ext4″ PARTLABEL=”Linux filesystem” PARTUUID=”7d48122f-0652-4540-933f-622cae2bfbab” /dev/sda4: UUID=”e8c1e7d8-eb42-4872-8685-58b8ffae1f2f” TYPE=”ext4″ PARTLABEL=”Linux filesystem” PARTUUID=”ff9f57af-edd0-4107-a108-363c1324ba7e” /dev/sda5: UUID=”70fef83e-4197-4b17-9833-8c3980a81743″ TYPE=”ext4″ PARTLABEL=”Linux filesystem” PARTUUID=”95588aa6-f7c3-4d09-a1b1-e2a4c8426f06” IMPORTANTE Não utilize os identificadores escritos aqui no artigo. São únicos e cada partição/dispositivo tem o seu. Use os códigos que lhe foram retornados quando o comando lsblk foi dado. Antes de editarmos o primeiro arquivo, /boot/cmdline.txt, efetue uma cópia de backup do mesmo. cp /boot/cmdline.txt /boot/cmdline.txt.bak Agora, edite o arquivo /boot/cmdline.txt com o editor de textos de sua preferência. No meu caso, o nano. nano /boot/cmdline.txt Onde está root=PARTUUID=algumaCoisa, apague o algumaCoisa e escreva o valor do PARTUUID da sua partição /dev/sda1, partição raiz do HD. No meu caso, o resultado do arquivo /boot/cmdline.txt é: dwc_otg.lpm_enable=0 console=serial0,115200 console=tty1 root=PARTUUID=f4a39e68-16b0-44c3-afd1-05dc0dea3973 initrd=0x01f00000 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait Então, vamos editar o arquivo fstab armazenado no HD. nano /mnt/raiz/etc/fstab Na linha que está PARTUUID=algumaCoisa / ext4 (…), vamos substituir o algumaCoisa pelo PARTUUID da partição raiz do HD, /dev/sda1. Além disso, vamos acrescentar mais 4 linha abaixo desta que modificamos referentes as outras partições, que terão como ponto de montagem os diretórios /home, /usr, /var, /tmp. No meu caso (apenas para exemplificar a estrutura, não copie, use seus valores), meu arquivo fstab ficou: Nota A cada parâmetro deve ser dado um “tab” de espaço, e não um “space” proc /proc proc defaults 0 0 PARTUUID=e1ae1d9f-01 /boot vfat defaults 0 2 PARTUUID=f4a39e68-16b0-44c3-afd1-05dc0dea3973 / ext4 defaults,noatime 0 1 PARTUUID=ab6f0c87-c856-40ab-8779-e7f0ab2414e8 /home ext4 defaults 0 2 PARTUUID=7d48122f-0652-4540-933f-622cae2bfbab /usr ext4 defaults 0 2 PARTUUID=ff9f57af-edd0-4107-a108-363c1324ba7e /var ext4 defaults 0 2 PARTUUID=95588aa6-f7c3-4d09-a1b1-e2a4c8426f06 /tmp ext4 defaults 0 # a swapfile is not a swap partition, no line here # use dphys-swapfile swap[on|off] for that ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:11:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"INITRAMFS Um requisito para que o sistema funcione em um HD Externo com alguns diretórios em diferentes partições, sejam partições GPT ou LVM, é a execução de uma imagem initramfs. Mas o que é uma imagem initramfs? De maneira resumida, antes da montagem do sistema de arquivos raiz e da execução do programa de inicialização do sistema (init), o Kernel precisa de módulos (drivers) para ser capaz de acessar o dispositivo em que o sistema de arquivos raiz está localizado. Em nosso caso, ao separar alguns diretórios do sistema em diferentes partições, torna-se necessário o pré-conhecimento de todas as partições para que seja possível montá-las. Logo, é justamente isso que o initramfs faz. Ele contém o mínimo exigido pelo kernel para reconhecer os dispositivos/partições e carregar o diretório raiz corretamente. mkinitramfs -o /boot/initramfs.gz Para instruir o Raspberry a usar a imagem initram que criamos é preciso configurar os arquivos: /boot/cmdline.txt e /boot/config.txt. Os parâmetros configurados especificam o endereço de memória onde a imagem vai iniciar e também o nome do arquivo de imagem dentro de /boot. A seguir o resultado dos dois arquivos já configurados. Os parâmetros para configurar a imagem estão destacados em negrito: /boot/cmdline.txt dwc_otg.lpm_enable=0 console=serial0,115200 console=tty1 root=/dev/mapper/raspberry-rootfs initrd=0x01f00000 rootfstype=ext4 elevator=deadline fsck.mode=force fsck.repair=yes rootwait /boot/config.txt #– Acrescente a linha abaixo no final do arquivo –# initramfs initramfs.gz 0x01f00000 Sem essas configurações o Raspberry não será capaz de iniciar o sistema a partir do HD Externo. 3.6. Reiniciar para que o sistema inicie a partir do HD Terminamos a parte para o esquema GPT. Agora é só reiniciar o Raspberry Pi 3 que o sistema rodará a partir do HD. Para demonstrar, reiniciei com shutdown -r now. A conexão SSH obviamente caiu. Aguardei alguns segundos (ao menos uns 20s) e tentei conectar via SSH no mesmo endereço IP que anteriormente. Obtive sucesso e fiz login. Em seguida, loguei como root. Dei o comando lsblk, e o resultado foi: Sistema rodando no HD (esquema GPT)Alt text \" Sistema rodando no HD (esquema GPT) Nota Importante Pode ser que o endereço IP do sistema, ao reiniciar e iniciar pelo HD, mude. Verifique a tabela de clientes ativos em seu roteador. 4. Passos para quem escolheu usar LVM (tabela de partições GPT + partições do tipo LVM) Recapitulando os passos: Instalar o LVM no sistema Apagar partições existentes no HD (esse passo apagará todos os dados do seu HD) Criar nova tabela de partições GPT vazia Criar uma partição de 500GB para ser o tamanho tota- do volume físico LVM Fazer a configuração LVM criando todas as partições lógicas Copiar o sistema Raspbian do cartão de memória para o HD Realizar as devidas configurações para que tudo funcione Reiniciar para que o sistema inicie a partir do HD ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:11:1","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"4.1. Instalar o LVM no sistema Já contextualizamos o LVM na seção de Esquemas de particionamento nativo (MBR), GPT e LVM; e quais diretórios Linux montar em partições separadas. Agora, começamos a botar a mão no teclado instalando o LVM no sistema. aptitude install lvm2 ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:12:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"4.2. Apagar partições existentes IMPORTANTE Se houver dados em seu HD e seguindo os passos a seguir, TODOS OS DADOS DO HD EXTERNO SERÃO PERDIDOS. Não se esqueça de realizar backup e ter um HD dedicado somente para os propósitos do projeto. Nota Todos os passos abaixo deverão ser realizados com todas as partições do HD desmontadas. Verifique qual dispositivo é o seu HD Externo no Raspbian com o comando fdisk -l ou lsblk, por exemplo. Em seguida, dê o comando gdisk /dev/seuDispositivo. No meu caso, o HD Externo é o dispositivo /dev/sda. Então ficou: gdisk /dev/sda Caso o utilitário gdisk não esteja instalado, instale-o com: aptitude install gdisk Prossiga digitando a letra d, para apagar todas as partições do HD Externo. Nota Se houver mais de uma partição, será perguntado qual o número da partição deseja apagar, mas também é mostrado entre parênteses quantas partições há. Exemplo: se aparecer Partition number (1-3), significa que há 3 partições (/dev/sda1, /dev/sda2, /dev/sda3). Apague todas. ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:13:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"4.3. Criar nova tabela de partições GPT vazia Depois, ainda dentro do gdisk, digite a letra (campo de cód) o para criar uma tabela de partição GPT vazia. Se houver alguma pergunta de confirmação, confirme com Y e prossiga. ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:14:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"4.4. Criar uma partição de 100GB para ser o tamanho total do volume físico LVM Continuando ainda dentro do utilitário gdisk, digite a letra n para adicionar uma nova partição no HD. Em Partition number, dê enter para escolher o número default, 1. Em First sector também dê somente enter. Em Last sector vamos definir o tamanho de 100GB, suficiente para abrigar todas as partições que definimos para LVM na seção de particionamento. Então digite: +100G e dê enter. Em Hex Code or GUID não é necessário fazer alteração, então dê somente enter para seguir com a opção default 8300, código que indica que é uma partição do tipo Linux filesystem. Info esse Hex Code é uma configuração opcional para a partição, que dá a ela um Label (rótulo). Caso queira dar um rótulo mais coerente com o que estamos configurando, digite “8e00”, que é o código para o Label “Linux LVM”. No meu caso, segui com a opção 8300 mesmo, Linux filesystem, para exemplificar que isso não terá efeito negativo em nossas configurações. Por fim, ainda dentro do gdisk, digite w (e faça as confirmações necessárias) para escrever todas as mudanças em disco e sair. Como pode ser observado na imagem a seguir, onde foi dado o comando fdisk -l, temos o HD com tabela de particionamento do tipo GPT e com a partição que acabamos de criar. Observe que esta partição é a /dev/sda1. Usaremos essa informação no próximo passo. HD com tabela de particionamento GPT e uma partição criadaAlt text \" HD com tabela de particionamento GPT e uma partição criada Nota Não é necessário formatar a partição que criamos ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:15:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"4.5. Fazer a configuração LVM criando todas as partições lógicas O particionamento LVM é formado por 3 elementos: o PV (Physical Volume/ Volume Físico) – elemento que define a área (partição) física do HD que será utilizada como LVM; VG (Volume Group/ Grupo de Volumes) – agrupa PV(Volumes Físicos). É essa subdivisão que receberá as partições lógicas (LG) do LVM dentro dela. Para fazer uma analogia, é semelhante a uma partição estendida do esquema de particionamento MBR; LG (Logical Group/ Grupo lógico) – são as partições do LVM, as quais montamos e gravamos dados. Parafazer uma analogia, são como as partições lógicas do esquema de particionamento MBR. Começaremos estabelecendo o Volume Físico (PV), ou seja, a área do HD que será utilizada como LVM. No passo anterior criamos uma partição de 100GB justamente para esse propósito. Então, para defini-la como um PV, faça: pvcreate /dev/sda1 Nota no meu caso, ao dar o comando pvcreate fui informado de que havia uma assinatura ext4 naquela área do HD, pois anteriormente essa minha partição foi utilizada com o sistema de arquivos ext4. Então me foi solicitado uma confirmação para limpar essa assinatura. Bastou confirmar com y e prosseguir. O próximo passo é criar um grupo de volumes (VG), estabelecendo um nome para ele (nomeei de raspberry; bem criativo) e já acrescentando o PV (Volume Físico) criado no passo anterior. Para isso: vgcreate raspberry /dev/sda1 Nota Só para já dar um exemplo das possibilidades de manipulação do LVM, poderemos adicionar mais PVs (Volumes Físicos) a este VG (Grupo de Volumes) “raspberry” que criamos. Até o momento, temos um Grupo de Volumes com 100GB. Se for criada mais um PV, seja no mesmo HD ou até mesmo em outro(!!), basta adicioná-lo (com os comandos corretos, claro) a este VG que seu tamanho será aumentado, dando possibilidade das partições (LGs) serem redimensionadas ou mesmo que mais partições sejam criadas. Agora vamos criar as LGs (Grupos Lógicos), ou seja, o que costumamos chamar de partições. Como planejado, criaremos 5 partições, com tamanhos que também já foram definidos, para abrigar 5 diferentes diretórios do Linux, sendo eles: 1) diretório raíz (/), 2) diretório /home, 3) diretório /usr, 4) diretório /var e 5) diretório /tmp. Para criar as partições, dê os comandos: lvcreate -L20G -n rootfs raspberry lvcreate -L20G -n home raspberry lvcreate -L20G -n usr raspberry lvcreate -L20G -n var raspberry lvcreate -L1G -n tmp raspberry Onde, -L20G define um tamanho de 20 Gigabytes, -n o nome do Volume Lógico (partição) e raspberry é o LG (Grupo Lógico) onde a partição será criada. Com os comandos pvs – exibe os PVs criados; vgs – exibe os VGs criados; lvs – exibe as partições; veremos o resultado de nossas configurações LVM. pvs vgs lvs No meu caso, o retorno dos comandos anteriores pode ser visto na imagem a seguir. Resultado das configurações LVMAlt text \" Resultado das configurações LVM Agora, falta formatar as partições que acabamos de criar com o sistema de arquivos ext4. Antes de darmos os comandos de formatação, precisamos verificar como as partições foram reconhecidas pelo sistema. Para isso, dê: fdisk -l Observe o retorno deste comando no meu caso, na imagem a seguir: Partições LVM reconhecidas pelo sistemaAlt text \" Partições LVM reconhecidas pelo sistema Veja que as partições LVM são reconhecidas como /dev/mapper/algumaCoisa. Sabendo disso, podemos dar o comando de formatação das partições. mkfs.ext4 /dev/mapper/raspberry-rootfs mkfs.ext4 /dev/mapper/raspberry-home mkfs.ext4 /dev/mapper/raspberry-usr mkfs.ext4 /dev/mapper/raspberry-var mkfs.ext4 /dev/mapper/raspberry-tmp As configurações LVM estão concluídas e as partições (lógicas) estão formatadas. Basta fazer a cópia do sistema do cartão do memória para as partições LVM no HD. ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:16:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"4.6. Copiar o sistema Raspbian do cartão de memória para o HD (esquema LVM) Agora vamos copiar o sistema Raspbian do cartão de memória para o HD Externo e fazer as devidas configurações para que tudo funcione. Siga a sequência de passos a seguir. Primeiro, vamos criar um diretório para cada partição dentro de /mnt: mkdir /mnt/raiz mkdir /mnt/home mkdir /mnt/usr mkdir /mnt/var mkdir /mnt/tmp Agora, monte as devidas partições em seus respectivos diretórios: mount /dev/mapper/raspberry-rootfs /mnt/raiz/ mount /dev/mapper/raspberry-home /mnt/home mount /dev/mapper/raspberry-usr /mnt/usr mount /dev/mapper/raspberry-var /mnt/var mount /dev/mapper/raspberry-tmp /mnt/tmp Após esses comandos, ao dar um lsblk o resultado da montagem das partições do HD será como o da imagem a seguir: Resultado da montagem das partições nos seus devidos diretóriosAlt text \" Resultado da montagem das partições nos seus devidos diretórios Com todas as partições montadas em seus devidos diretórios, resta iniciar a cópia do sistema. Para copiar do diretório / do cartão de memória todos os seus arquivos e subdiretórios para o HD, dê o comando: cp -ax / /mnt/raiz/ Info onde, -a especifica que a estrutura original dos arquivos – atributos, permissões, links simbólicos, etc – devem ser preservadas, além de que faz a cópia recursiva, ou seja, copia diretórios. -x especifica que o cp deve operar somente no sistema de arquivos onde o comando foi executado. Se o cp tentar atravessar o limite para outro sistema de arquivos, esses arquivos serão ignorados. Isso inclui unidades de rede, outras partições, ou seja, qualquer arquivo que esteja em um ponto de montagem diferente. Só para exemplificar, nesse caso, o diretório /boot não será copiado para o HD, pois está montado em uma partição diferente de onde o comando cp foi executado. Mais precisamente, /boot está na partição /dev/mmcblk0p1 do cartão de memória e o comando cp está na partição raiz do sistema, /dev/mmcblk0p2. Se houver curiosidade, dê um ls no diretório /mnt/raiz/boot após a cópia terminar. Não haverá nada nele. Terminada a cópia do diretório raiz do cartão de memória para o HD Externo, devemos agora copiar os diretórios home, usr e var de /mnt/raiz para as partições que dedicamos exclusivamente para estes diretórios e que estão montadas em /mnt/home, /mnt/usr e /mnt/var respectivamente. Não é necessário copiar o diretório /mnt/raiz/tmp para /mnt/tmp, pois o conteúdo deste diretório é deletado a cada boot. Porém, foi importante montarmos este diretório mesmo assim, para nos lembrarmos posteriormente de apagar o conteúdo que está dentro do diretório raiz (/mnt/raiz/tmp). Para copiar os diretórios restantes para suas devidas partições dedicadas, dê: cp -ax /mnt/raiz/home/* /mnt/home/ cp -ax /mnt/raiz/usr/* /mnt/usr/ cp -ax /mnt/raiz/var/* /mnt/var/ Copiados todos os diretórios para suas devidas partições dedicadas, devemos apagar os conteúdos que estão nos diretórios home, usr, var e tmp dentro da partição /dev/sda1, que está montada em /mnt/raiz, porque quando iniciarmos o sistema a partir do HD perderemos acesso a eles, já que estes diretórios vão apontar para os conteúdos gravados em suas respectivas partições (sda2, sda3, sda4 e sda5). Para executar esta tarefa de deleção, dê: rm -rf /mnt/raiz/home/* rm -rf /mnt/raiz/usr/* rm -rf /mnt/raiz/var/* rm -rf /mnt/raiz/tmp/* ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:17:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"4.7. Realizar as devidas configurações para que tudo funcione Terminado o processo de cópia, falta apenas realizar algumas configurações para que o sistema no HD inicie corretamente. São dois passos, 1) parametrizar o arquivo de boot cmdline.txt para especificar que a partição raiz do sistema está no HD e não no cartão de memória; e 2) configurar os pontos de montagem das partições no arquivo fstab. Se estivissemos configurando partições comuns, fosse GPT ou MBR, a melhor prática para configurá-las em arquivos de configuração como o fstab seria identificá-las através de identificadores de dispositivos/partições, UUID ou PARTUUID (esse último sendo padrão do Raspbian). Porém, no LVM isso muda, pois essas partições são lógicas e dependem dos módulos (drivers) e dos programas do LVM para funcionarem e isso pode influenciar na maneira em que são reconhecidas pelo sistema operacional. Logo, ao pesquisar um pouco sobre o assunto verifiquei que a melhor prática para configurar a montagem de partições LVM, em arquivos de configuração, é usando os identificadores /dev/mapper/volumeGroup-logicalVolume. Os comandos fdisk -l, já usado anteriormente, e o blkid são comandos que retornam esses caminhos/identificadores completos das partições LVM. Sabendo disso, seguiremos a parametrização dos arquivos de configuração com a melhor prática. Antes de editarmos o primeiro arquivo, /boot/cmdline.txt, efetue uma cópia de backup do mesmo. cp /boot/cmdline.txt /boot/cmdline.txt.bak Agora, edite o arquivo /boot/cmdline.txt com o editor de textos de sua preferência. No meu caso, o nano. nano /boot/cmdline.txt Onde está root=PARTUUID=algumaCoisa, apague o PARTUUID=algumaCoisa e escreva o caminho/identificador da partição LVM raiz. O resultado do arquivo /boot/cmdline.txt é: dwc_otg.lpm_enable=0 console=serial0,115200 console=tty1 root=/dev/mapper/raspberry-rootfs initrd=0x01f00000 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait Então, vamos editar o arquivo fstab armazenado no HD. nano /mnt/raiz/etc/fstab Neste arquivo nós configuramos os pontos de montagem de partições. É aqui que especificamos que os diretórios home, usr, var e tmp terão suas próprias partições ao invés de ficarem juntas na mesma partição do / (raiz). Comece apagando a linha PARTUUID=e1ae1d9f-02 / … No lugar dessa linha que apagamos, especificaremos a configuração da partição e diretório raiz, ficando: /dev/mapper/raspberry-rootfs / ext4 defaults,noatime 0 1 Em seguida, na linha abaixo dessa que configuramos, especificaremos todas as outras partições e diretórios. A seguir, o resultado do arquivo fstab todo configurado: Nota A cada parâmetro deve ser dado um “tab” de espaço, e não um “space” proc /proc proc defaults 0 0 PARTUUID=e1ae1d9f-01 /boot vfat defaults 0 2 /dev/mapper/raspberry-rootfs / ext4 defaults,noatime 0 1 /dev/mapper/raspberry-home /home ext4 defaults,noatime 0 2 /dev/mapper/raspberry-usr /usr ext4 defaults,noatime 0 2 /dev/mapper/raspberry-var /var ext4 defaults,noatime 0 2 /dev/mapper/raspberry-tmp /tmp ext4 defaults,noatime 0 2 # a swapfile is not a swap partition, no line here # use dphys-swapfile swap[on|off] for that ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:18:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"INITRAMFS Um requisito para que o sistema funcione em um HD Externo com alguns diretórios em diferentes partições, sejam partições GPT ou LVM, é a execução de uma imagem initramfs. Mas o que é uma imagem initramfs? De maneira resumida, antes da montagem do sistema de arquivos raiz e da execução do programa de inicialização do sistema (init), o Kernel precisa de módulos (drivers) para ser capaz de acessar o dispositivo em que o sistema de arquivos raiz está localizado. Em nosso caso, ao separar alguns diretórios do sistema em diferentes partições, torna-se necessário o pré-conhecimento de todas as partições para que seja possível montá-las. Logo, é justamente isso que o initramfs faz. Ele contém o mínimo exigido pelo kernel para reconhecer os dispositivos/partições e carregar o diretório raiz corretamente. mkinitramfs -o /boot/initramfs.gz Para instruir o Raspberry a usar a imagem initram que criamos é preciso configurar os arquivos: /boot/cmdline.txt e /boot/config.txt. Os parâmetros configurados especificam o endereço de memória onde a imagem vai iniciar e também o nome do arquivo de imagem dentro de /boot. A seguir o resultado dos dois arquivos já configurados. Os parâmetros para configurar a imagem estão destacados em negrito: /boot/cmdline.txt dwc_otg.lpm_enable=0 console=serial0,115200 console=tty1 root=/dev/mapper/raspberry-rootfs initrd=0x01f00000 rootfstype=ext4 elevator=deadline fsck.mode=force fsck.repair=yes rootwait /boot/config.txt #-- Acrescente a linha abaixo no final do arquivo --# initramfs initramfs.gz 0x01f00000 Sem essas configurações o Raspberry não será capaz de iniciar o sistema a partir do HD Externo. ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:18:1","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"4.8. Reiniciar para que o sistema inicie a partir do HD Terminamos. Agora é só reiniciar o Raspberry Pi 3 que o sistema rodará a partir do HD. Para demonstrar, reiniciei com shutdown -r now. A conexão SSH obviamente caiu. Aguardei alguns segundos (ao menos uns 20s) e tentei conectar via SSH no mesmo endereço IP que anteriormente. Obtive sucesso e fiz login. Em seguida, loguei como root. Dei o comando lsblk, e o resultado foi: Retorno do comando lsblk com o sistema rodando no HD em partições LVMAlt text \" Retorno do comando lsblk com o sistema rodando no HD em partições LVM Nota Pode ser que o endereço IP do sistema, ao reiniciar e iniciar pelo HD, mude. Verifique a tabela de clientes ativos em seu roteador. 5. Comparação de velocidade de leitura/escrita entre cartão de memória MicroSD e HD Externo Todo esse trabalho para fazer o Raspberry rodar seu sistema operacional a partir do HD Externo deve ter alguma justificativa muito, muito boa! E sim, tem mesmo. Além de sanar o problema da limitada vida útil de um cartão de memória, rodar o sistema operacional Raspbian em um HD Externo é muito mais rápido. Sem mais delongas, vou deixar as imagens falarem por si só. Método de escrita: dd bs=1M count=1024 if=/dev/zero of=testrw conv=fdatasync Esse método de escrita no HD, segundo Roman Mamedov no link https://romanrm.net/dd-benchmark, diz ao dd para requisitar uma sincronização completa, apenas uma vez, logo antes do dd terminar sua tarefa. Ou seja, ao escrever todos os 1024MB de dados o dd pede ao sistema operacional: “agora certifique-se de que todos esses dados estejam no disco”. Somente após o sistema operacional retornar a informação de que os dados já estão no disco é que o dd para de medir o tempo total da operação e retorna o resultado das medições. Porque todo esse capricho? Se simplesmente solicitássemos uma operação de escrita com dd sem o parâmetro conv=fdatasync ficando dd bs=1M count=1024 if=/dev/zero of=testrwo sistema operacional só ia realmente escrever os dados em disco quando fosse conveniente a ele; e os resultados de medição do dd não seriam fieis, pois nesse caso os dados são armazenados no Buffer da RAM (write cache) e essa tarefa é bem rápida. Enfim, foi utilizado um método que testa de maneira mais fiel a tarefa de escrita em disco. Método de leitura: echo 3 \u003e /proc/sys/vm/drop_caches dd if=testrw of=/dev/null bs=1M count=1024 O primeiro comando, echo 3 \u003e /proc/sys/vm/drop_caches, limpa o buffer-cache existente, fazendo com que o sistema não aproveite para ler os dados diretamente dessa área de cache e sim do disco. Em seguida o comando de leitura com dd que foi escrito logo atrás. Nota importante Observação: vale citar que no momento do teste de leitura e escrita, o sistema operacional estava rodando no dispositivo sendo testado. Por exemplo: ao testar leitura e escrita no cartão de memória, o sistema operacional estava sendo executado nele no momento do teste. O mesmo vale para o HD Externo. Utilizando esses métodos, na imagem a seguir temos o resultado da velocidade de escrita e leitura, respectivamente, do cartão MicroSD: Velocidade de escrita e leitura do cartão de memória MicroSDAlt text \" Velocidade de escrita e leitura do cartão de memória MicroSD Utilizando os mesmo métodos, na imagem a seguir temos o resultado da velocidade de escrita e leitura, respectivamente, do HD Externo. Primeiro o teste com as partições comuns da tabela de particionamento GPT: Velocidade de escrita e leitura do HD Externo com partições comuns do esquema GPTAlt text \" Velocidade de escrita e leitura do HD Externo com partições comuns do esquema GPT Para finalizar o teste com as partições do tipo LVM + tabela de particionamento GPT: Velocidade de escrita e leitura do HD Externo com partições do tipo LVMAlt text \" Velocidade de escrita e leitura do HD Externo com partições do tipo LVM Me surpreendi ao ter uma velocidade ligeiramente mais rápida em partições LVM do que partições primárias comuns. Esse assunto é batante discutido e ","date":"13-12-2018","objectID":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/:19:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","lvm","gpt","particionamento","backpower","hub usb","gdisk","cp","mkfs","initram","fstab","dd"],"title":"Rodando o sistema do Raspberry Pi 3 em um HD Externo – Parte 4 do Projeto","uri":"/rodando-o-sistema-do-raspberry-pi-3-em-um-hd-externo/"},{"categories":null,"content":"Inicialmente, meu objetivo final quando comecei este projeto era esta parte: a parte em que vamos implementar os serviços de ponto de acesso Wi-Fi e de servidor DHCP. Com esses dois serviços configurados e mais algumas configurações de rede e firewall, o Raspberry se torna capaz de substituir muito roteador residencial com propriedade. Reflita: terás um sistema Linux estável e totalmente configurável, com hardware superdimensionado quando comparado a de roteadores residenciais, gerenciando sua rede Wi-Fi e seu acesso a Internet. Acredito que, “robusto” é uma possível palavra de reação para o que acabamos de ler. Além disso, haverá a possibilidade de estender as funções do Raspberry. “Preciso de VPN = instale o serviço”. “Meu videogame está com problema para acessar o servidor do jogo = nada que uma regrinha no iptables não resolva”. “Será útil compartilhar arquivos entre os computadores da minha residência = só configurar”. “Quero implementar um site (meu caso) = vá em frente”. As possibilidades são infinitas, ainda sem entrar no mérito das possíveis automações elétricas e eletrônicas que o Raspberry é capaz de fazer graças aos seus pinos programáveis. Enfim, esta parte do projeto, depois de pronta, serviu de inspiração para eu continuar tendo ideias, realizar experimentos e, resumidamente, chegar ao nível de desenvolver um site. Espero que, depois de implementada, esta parte também sirva de inspiração para você continuar experimentando e aprendendo com o seu Rasp. Conteúdo Nesta parte teremos: O que será necessário: Minha topologia de rede Configuração das nomenclaturas das interfaces de rede Configuração do arquivo interfaces Instalação e configuração do serviço hostapd para fazer do Raspberry um ponto de acesso Wi-Fi Instalação e configuração do serviço isc-dhcp-server Compartilhamento da Internet e configuração de um script de regras para o Firewall iptables Fontes O que será necessário: Conectar o Raspberry na rede via cabo Acessar o Raspberry via SSH para configurá-lo Minha topologia de rede 1. Configuração das nomenclaturas das interfaces de rede “Antigamente” o Linux estabelecia a nomenclatura de suas interfaces de rede de maneira sequencial. Para exemplificar, imagine o cenário de 2 placas Ethernets e 2 Wi-Fi instaladas no computador. Logo, teríamos as interfaces eth0, eth1, wlan0 e wlan1. Os nomes (eth0, wlan0, etc) eram dados para as interfaces assim que fossem reconhecidas pelo kernel, e o problema desse mecanismo de reconhecimento das interfaces é que o mesmo não era previsível, podendo durante o processo de boot reconhecer primeiro a placa que antes do reboot era eth1, e então dar o nome de eth0 a ela. Aí, já viu, todas as configurações destinadas a uma placa iria para a outra e a confusão estaria feita. O novo mecanismo para nomear as interfaces de rede considera, em sequência, políticas para dar nomes. A primeira informação/política que estiver disponível, é então usada para nomear a interface. Segue lista das políticas e possíveis nomes (placa ethernet) para cada uma: Nomes baseados na informação de Firmware/BIOS On-Board = eno1 Nomes baseados na informação de Firmware/BIOS PCI Express = ens1 Nomes baseados na informação de Localização Física do Hardware = enp2s0 Nomes baseados na informação de Endereço Físico (MAC) = enx020b1c4d5ef6 Nomes Clássicos Nativos do Kernel (Imprevisíveis) = eth0 Porém, muitos administradores são extremamente acostumados com os nomes comuns (eth0, wlan0) e preferem utilizá-los para suas configurações. Na minha opinião, configurar um nome próprio e fixo para as interfaces de rede facilita o trabalho de um administrador de rede. Portanto, iremos configurar nomes de interfaces de maneira que não mudem e que sempre se relacionem com a mesma placa de rede. Primeiro, descubra os endereços MAC das placas de rede ethernet e Wi-Fi do Raspberry dando o comando ip l (alias para o comando ip link) Para ficar mais claro onde localizar o endereço MAC de cada placa, observe os quadros vermelhos des","date":"06-12-2018","objectID":"/raspberry-como-roteador-wi-fi-parte-3-do-projeto/:0:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","hostapd","dhcp","redes"],"title":"Raspberry como roteador Wi-Fi – Parte 3 do Projeto","uri":"/raspberry-como-roteador-wi-fi-parte-3-do-projeto/"},{"categories":null,"content":"Após fazer a instalação do sistema operacional Raspbian Lite no Raspberry Pi 3 no artigo anterior, precisamos agora realizar algumas configurações básicas, para que o sistema fique bem configurado e estável para o uso. Além disso, já vamos realizar algum gerenciamento de usuários, configurar o básico de rede, deixar o sistema acessível via SSH e atualizar o sistema. Mãos ao teclado! Nesta parte teremos: Login no sistema Configurações regionais do sistema (linguagem, layout de teclado, etc) Expansão da partição de sistema no cartão de memória Exclusão do usuário pi Criação de um novo usuário Configuração do serviço OpenSSH Server Configuração de conexão Wi-Fi ou via cabo Conectar-se ao Raspberry via SSH Atualização do sistema O que será necessário: Monitor com entrada HDMI Teclado Rede LAN configurada para que o Raspberry ingresse nela, tornado-se possível acessá-lo via SSH a partir de outro computador na rede. 1. Login no sistema Alguns segundos após iniciar o sistema pela primeira vez, nos deparamos com uma tela de login onde é pedido, obviamente, usuário e senha. Para ser sincero, na primeira vez que instalei e iniciei o sistema, por ter sido precipitado e não ter lido as documentações no site Raspberrypi.org, me perguntei: e agora? hahaha. Esta informação está nas documentações do Raspberrypi.org neste link a seguir: https://www.raspberrypi.org/documentation/linux/usage/users.md Mas, para você que está acompanhando essa ótima série de artigos sobre o projeto, aqui está a informação: Usuário: pi Senha: raspberry Como podemos observar, temos um nome de usuário e senha padrão bem forte no quesito segurança. Só que não!!!! Justamente por esse motivo, teremos um passo nesta parte do projeto explicando como excluir esse usuário padrão, já que a sua existência, na minha opinião, só é mais um pequeno risco à segurança de nosso sistema. 2. Configurações regionais do sistema Para configurar localização e idioma do sistema, fuso-horário e layout de teclado, dê o comando: sudo raspi-config Aparecerá uma tela como a da imagem a seguir: O intuito não é explicar detalhadamente as opções deste menu ou como se usa ele, pois não é foco do artigo dar explicações de nível mais iniciante. Porém, segue dicas de navegação para este menu: Setas do teclado para navegar dentre as opções Enter para confirmar uma opção / seleção Tab para alternar entre os sub-menus Espaço para marcar alguma opção do estilo checkbox Para configurar as opções regionais, selecione a opção 4, Localisation Options. Dentro deste menu, recomendo que sejam configuradas as opções Locale, Timezone e Keyboard Layout, de acordo com suas preferências. Feitas estas configurações, não saia do menu do rasp-config ainda. 3. Expansão da partição de sistema no cartão de memória Neste link https://www.raspberrypi.org/documentation/configuration/raspi-config.md é citado que se a instalação foi feita usando o NOOBS (método de instalação mais automático e fácil), então o sistema de arquivos foi expandido automaticamente quando o sistema foi iniciado pela primeira vez. Como não é o nosso caso, ou seja, utilizamos outro método para realizar a instalação, devemos nos certificar de que o sistema de arquivos seja expandido. Mas afinal, o que é isso? Por que isso é necessário expandir o sistema de arquivos? Como instalamos o sistema a partir de uma imagem pronta, apenas copiando-a (da maneira correta, claro) para o cartão de memória, ela ocupa um espaço inicial de aproximadamente 2GB no cartão, e o sistema de arquivos do diretório root (me refiro ao diretório / e não a pasta “home” do usuário root) que é EXT4, reconhece que está instalado em uma partição deste tamanho, somente. Logo, precisamos informar ao sistema de arquivos desta partição que ela tem mais espaço para trabalhar, já que o cartão de memória é maior que apenas 2GB. Isto pode ser feito através do menu raspi-config. Após entrar no menu do raspi-config com $sudo raspi-config, selecione a opção Advanced Options e depois a opção Expand ","date":"30-11-2018","objectID":"/primeiras-configuracoes-no-raspbian-lite/:0:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","ssh","aptitude"],"title":"Primeiras Configurações no Raspbian Lite – Parte 2 do Projeto","uri":"/primeiras-configuracoes-no-raspbian-lite/"},{"categories":null,"content":"Instalação do Raspbian Lite em um cartão SD.","date":"09-10-2018","objectID":"/instalar-o-raspbian-lite-no-raspberry-pi-3-model-b-parte-1-do-projeto/","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","dd","unzip"],"title":"Instalar O Raspbian Lite No Raspberry Pi 3 Model B - Parte 1 Do Projeto","uri":"/instalar-o-raspbian-lite-no-raspberry-pi-3-model-b-parte-1-do-projeto/"},{"categories":null,"content":"Nesta parte teremos: Instalação do Raspbian Lite em um cartão SD. O que será necessário: Um cartão de memória Micro SD (podendo ser dos tipos SD, SDHC e SDXC) compatível* com Raspberry Pi 3 Model B de no mínimo 4GB, mas eurecomendo ao menos 16GB, o que dá mais folga para a instalação de ferramentas e serviços; Um computador com alguma distro Linux instalada, de preferência baseada em Debian que foi a distro a utilizada durante o Projeto; Uma maneira de inserir o cartão de memória do tipo Micro em seu computador. Há adaptadores para isso, por exemplo, USB. Nota Sobre a compatibilidade do cartão Micro SD, segue link com uma extensa lista de marcas e modelos que já se conhece se são compatíveis ou não. https://elinux.org/RPi_SD_cards#Working_.2F_Non-working_SD_cards. Para mais informações e também para entender melhor a relação Cartão SD e Raspberry Pi, acesse os links https://www.raspberrypi.org/documentation/installation/sd-cards.md e https://elinux.org/RPi_SD_cards. Contextualização A versão do Raspbian utilizada no projeto e também a atual no momento é o Raspbian Stretch Lite. Além do Raspbian ser baseado no Debian, ele também utiliza os nomes das versões do Debian, e daí vem o “Stretch” no nome Curiosidade A versão do Raspbian utilizada no projeto e também a atual no momento é o Raspbian Stretch Lite. Além do Raspbian ser baseado no Debian, ele também utiliza os nomes das versões do Debian, e daí vem o “Stretch” no nome ","date":"09-10-2018","objectID":"/instalar-o-raspbian-lite-no-raspberry-pi-3-model-b-parte-1-do-projeto/:0:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","dd","unzip"],"title":"Instalar O Raspbian Lite No Raspberry Pi 3 Model B - Parte 1 Do Projeto","uri":"/instalar-o-raspbian-lite-no-raspberry-pi-3-model-b-parte-1-do-projeto/"},{"categories":null,"content":"Por que Raspbian Lite? Como o objetivo do projeto é utilizar o Raspberry para fornecer e gerir alguns serviços de rede, não será necessário utilizá-lo como um Desktop, que possui ambiente gráfico com ferramentas como calculadora, navegador de internet, reprodutor de mídias, etc. Pelo contrário, precisamos utilizar um sistema que consuma o menos de memória RAM e processador possível, para que o poder computacional fique o máximo disponível para os serviços implementados. Como o próprio raspberrypi.org descreve, o Raspbian Lite é “Minimal image”, ou seja, um sistema operacional com o mínimo necessário para funcionar, e a partir disso instalamos e personalizamos para a nossa necessidade. Logo, um sistema ideal para o projeto. Nota O Raspbian também possui uma versão Desktop, com ambiente gráfico e as devidas ferramentas básicas para esse ambiente. Chega de papo, mãos ao teclado! Instalação do Raspbian Lite no Raspberry PI a partir do Linux Os passos de instalação do Raspbian a seguir se baseou no link https://www.raspberrypi.org/documentation/installation/installing-images/linux.md, onde é dado um passo a passo mais avançado devido ao uso de ferramentas via terminal a partir de um sistema Linux. Se você não tem muita familiaridade com comandos via terminal, indico o link https://www.raspberrypi.org/documentation/installation/installing-images/README.md onde é instruído o uso de uma ferramenta gráfica, que pode ser usada dos sistemas Windows, Mac OS e Linux, para a gravação do sistema em um cartão SD. Será necessário um cartão de memória Micro SD de no mínimo 4GB e livre para a instalação e uso do sistema. O cartão não poderá ser utilizado para outro fim e os dados que estiverem no cartão serão apagados. Cuidado! Quais os passos: Download do sistema Raspbian Lite Descompactação do arquivo baixado Identificação e preparação do cartão de memória Gravação do sistema no cartão de memória 1. Download do sistema Raspbian Lite Para começar, faça o Download da última versão do sistema Raspbian Lite no link: https://www.raspberrypi.org/downloads/raspbian/ Nota No caso do projeto foi escolhido o Download do ZIP. No meu caso foi utilizado um cartão de memória SanDisk Micro SDHC 1 Classe 4 de 16GB. Particularmente, não foi minha prioridade escolher um bom cartão de memória, com boa velocidade e etc, pois a minha real intenção era rodar o sistema em um HD Externo, coisa que aconteceu e que vou abordar nas próximas partes do Projeto. Se você leitor, tem o intuito de deixar o sistema rodando em um cartão de memória, recomendo que preocupe-se com o limitado ciclo de leituras e escritas que uma cartão de memória pode realizar. Ou seja, se esse limite for atingido enquanto o sistema estiver funcionando, provavelmente ele parará de funcionar e os dados armazenados poderão ser perdidos. Por isso, recomende que pesquise sobre o assunto. A seguir um link de uma discussão interessante sobre este assunto: https://pt.stackoverflow.com/questions/8990/qual-é-a-vida-útil-de-um-cartão-sd-com-raspbian-raspberry-pi Vamos voltar ao que interessa… Depois de baixar a imagem do sistema operacional Raspbian Lite, teremos um arquivo (imagem do sistema Raspbian Lite) na pasta escolhida para receber o download, parecido com esse: Arquivo zip do Raspbian LiteAlt text \" Arquivo zip do Raspbian Lite 2. Descompactação do arquivo baixado Logo, vamos descompactar esse arquivo unzip 2018-06-27-raspbian-stretch-lite.zip Descompactação do arquivo zip, gerando a imagem (img) do sistema RaspbianAlt text \" Descompactação do arquivo zip, gerando a imagem (img) do sistema Raspbian Pronto! Já temos o sistema pronto para ser gravado no cartão de memória. Agora, vamos preparar o cartão para receber o sistema. 3. Identificação e preparação do cartão de memória Nesse momento, insira o cartão em seu computador. Quando um cartão de memória ou pendrive, por exemplo, é inserido no computador, o Linux os reconhece como um dispositivo e todo dispositivo tem um nome. Para descobrir o nome do di","date":"09-10-2018","objectID":"/instalar-o-raspbian-lite-no-raspberry-pi-3-model-b-parte-1-do-projeto/:1:0","tags":["Raspberry Pi","Raspbian","Linux","Infraestrutura","dd","unzip"],"title":"Instalar O Raspbian Lite No Raspberry Pi 3 Model B - Parte 1 Do Projeto","uri":"/instalar-o-raspbian-lite-no-raspberry-pi-3-model-b-parte-1-do-projeto/"},{"categories":null,"content":"Esse é o projeto que deu vida ao site Coisas de Infra. A seguir nesta página, contextualizo o projeto, conto como surgiu a ideia desse site e quais os objetivos com tudo isso. Além disso, também escrevo sobre as motivações. Antes de mais nada, os artigos técnicos sobre o projeto seguirão divididos em partes (parte 1, parte 2, etc). Essa sequência de partes formará um sistema base que será utilizado em outros artigos que não farão parte desta sequência. O índice dos artigos estão em seguida deste parágrafo. Sempre que um novo artigo desta sequência for postado, atualizarei este índice com os respectivos links para os artigos. Parte 1: Instalar o Raspbian Lite No Raspberry Pi 3 Model B Parte 2: Primeiras Configurações no Raspbian Lite Parte 3: Raspberry como roteador Wi-Fi Parte 4: Rodando o sistema do Raspberry Pi 3 em um HD Externo ","date":"08-10-2018","objectID":"/projeto-infra-com-raspberry-pi-3/:0:0","tags":["blog","free software","projeto","Raspberry Pi","Raspbian","Linux","Infraestrutura"],"title":"Projeto Infra com Raspberry PI 3 Model B / Origem do Site","uri":"/projeto-infra-com-raspberry-pi-3/"},{"categories":null,"content":"Contextualização A ideia inicial desse projeto era implementar um sistema que me servisse de plataforma de estudo, tendo a base necessária para a realização de experimentos em Administração de Sistemas, Redes de Computadores e Segurança da Informação. Por ter tido a experiência de escrever relatórios e artigos para um projeto de Iniciação Científica durante a minha graduação na faculdade, senti necessidade de ter um “lugar” para escrever sobre esse projeto, para poder compartilhar conhecimento, criar um portfólio de experiências e conteúdos, além de que também poderia servir para possíveis discussões sobre os assuntos. Logo, a ideia do projeto mais a necessidade de um lugar para escrever sobre ele se transformou em uma ideia só: implementar um servidor residencial que gerencie a rede e também sirva de base para ser um servidor web, assim podendo hospedar o blog onde eu escreveria sobre essas implementações/experiências. Assim nasceu o blog Coisas de Infra. ","date":"08-10-2018","objectID":"/projeto-infra-com-raspberry-pi-3/:1:0","tags":["blog","free software","projeto","Raspberry Pi","Raspbian","Linux","Infraestrutura"],"title":"Projeto Infra com Raspberry PI 3 Model B / Origem do Site","uri":"/projeto-infra-com-raspberry-pi-3/"},{"categories":null,"content":"Objetivos Então, formei objetivos para o projeto. Foram eles: Custo zero e Software Livre. Tirando o custo com os periféricos (hardwares) a ideia foi seguir o “faça você mesmo” e utilizar somente ferramentas (e sistema operacional) Free Software ou Open Source, assim não gastando com licenças de softwares pagos. Estudar sobre Administração de Sistemas Linux, Redes, Segurança da informação, ou basicamente, sobre Infraestrutura de T.I. Mostrar um pouco do meu trabalho. Compartilhar conhecimento e informação e estimular discussões sobre tudo que for abordado no blog. Compactuar com as ideias da comunidade Open Source/Free Software. Acho que já foi possível captar esse objetivo após ler o primeiro. ","date":"08-10-2018","objectID":"/projeto-infra-com-raspberry-pi-3/:2:0","tags":["blog","free software","projeto","Raspberry Pi","Raspbian","Linux","Infraestrutura"],"title":"Projeto Infra com Raspberry PI 3 Model B / Origem do Site","uri":"/projeto-infra-com-raspberry-pi-3/"},{"categories":null,"content":"Motivações Alguns porquês do projeto possuir essa configuração (Raspberry, Free Software, Experimentos de Infra). Por ser um Single Board Computer (computador de placa única), o Raspberry Pi é um computador completo com baixo consumo de energia elétrica, sendo ideal para ficar ligado o tempo todo sem trazer custo significativo na conta de energia. Possui poder computacional suficiente para gerir uma rede residencial e também dar conta do tráfego de um site de pequeno porte. Administrar um sistema Linux, implementar e configurar serviços que esse sistema operacional oferece para gerenciamento de rede e segurança. Eu acredito que implementar e configurar serviços Free Software / Open Source nos deixam mais perto de como esses serviços funcionam e nos dão a base para trabalhar com qualquer outra solução. O modem/roteador Wi-Fi oferecido pela minha provedora de Internet está ultrapassado e fornece Wi-Fi no padrão 802.11G. Já o Raspberry Pi 3 Model B é capaz de fornecer Wi-Fi em um padrão mais recente, o 802.11N. Ao configurar o Raspberry Pi 3 como roteador Wi-Fi, torna-se possível realizar comparações entre o desempenho do modem/roteador da provedora assim como a diferença dos padrões Wi-Fi. Obter a experiência de implementar e gerir todos os serviços necessários para que um servidor web funcione bem. Caberá aqui bastante preocupação com a segurança. ","date":"08-10-2018","objectID":"/projeto-infra-com-raspberry-pi-3/:3:0","tags":["blog","free software","projeto","Raspberry Pi","Raspbian","Linux","Infraestrutura"],"title":"Projeto Infra com Raspberry PI 3 Model B / Origem do Site","uri":"/projeto-infra-com-raspberry-pi-3/"},{"categories":null,"content":"Curiosidade O nome do site veio durante o banho (bem clichê, mas verdade). Como os primeiros artigos do site seriam sobre o projeto com o Raspberry Pi, dispositivo o qual se encaixa dentro da “Internet das Coisas”, e o site com um maior foco em assuntos relacionados a Infraestrutura de T.I, ficou então Coisas de Infra. ","date":"08-10-2018","objectID":"/projeto-infra-com-raspberry-pi-3/:4:0","tags":["blog","free software","projeto","Raspberry Pi","Raspbian","Linux","Infraestrutura"],"title":"Projeto Infra com Raspberry PI 3 Model B / Origem do Site","uri":"/projeto-infra-com-raspberry-pi-3/"},{"categories":null,"content":"Resumo Aos 13 anos me descobri na tecnologia ao cursar Hardware e Redes e prestar o primeiro suporte a computador para um cliente. Desde então, sou fascinado por Linux, Redes e Segurança. Entusiasta em IoT, apresentei meu TCC para o curso técnico de mecatrônica utilizando Arduino, e isso me rendeu o cargo de professor de programação durante um ano na escola onde estudava. Na faculdade (TADS FT UNICAMP), ao trabalhar em uma iniciação científica, publiquei um artigo sobre segurança em redes no SBSeg 2017 e um resumo no Congresso de IC da UNICAMP. Então, me encantei pela produção de conteúdo e desenvolvi as habilidades de pesquisa, estudo e aprendizagem. Tive uma experiência privilegiada de estágio. Trabalhei com profissionais exemplares, aprendi processos maduros e participei da contínua melhoria deles. Pude conhecer melhor a área de Governança de T.I e tive contato direto com uma infraestrutura grande, complexa e muito bem gerenciada, toda open source. Foi marcante! Acredito que a informação aberta e o compartilhamento do conhecimento têm o potencial para produzir grandes inovações e soluções. Hoje, atuo como administrador de sistemas na HST, trabalhando com as tecnologias que eu sempre gostei e admirei. Link para visualizar artigo publicado no SBSeg 2017: http://doi.org/10.5281/zenodo.1039050 Link para visualizar resumo publicado pelo XXV Congresso de Iniciação Científica da UNICAMP: http://dx.doi.org/10.19146/pibic-2017-77893 Redes sociais para contato https://www.linkedin.com/in/matheus-dias-queiroz/ Galeria ","date":"07-10-2018","objectID":"/about/:0:0","tags":null,"title":"Sobre o Matheus","uri":"/about/"}]